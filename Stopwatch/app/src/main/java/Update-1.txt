1. По какой причине пакет timerdb вынесен отдельно (вне stopwatch)? Интересно просто. Мы обычно
    создаем пакет db рядом с остальными

2. DbContext
    @Override
    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVer,
                          int newVer){
        try{
            // Самое простое решение.
            TableUtils.dropTable(connectionSource, Properties.class, true);
            TableUtils.dropTable(connectionSource, TimeManager.class, true);
            TableUtils.dropTable(connectionSource, TimeCutoff.class, true);
            onCreate(db, connectionSource);
        }
        catch (SQLException e) {
            Log.e(TAG, "Ошибка обновления БД "+ DATABASE_NAME + " с версии " + oldVer);
            throw new RuntimeException(e);
        }
    }
Ну тут вы и сами написали в комментарии про "простое решение". Вообще, конечно, так делать не
стоит, поскольку юзер, теряющий данные при обновление приложения вряд ли будет рад.

3. PreferencesFragment.
    PreferencesFragment extends PreferenceFragment { ....
    Можно запутаться при импорте. Лучше было назвать как-то более однозначно.

4. PreferencesFragment
    Я специально про него написал в явном виде, предполагая, что вы будете использовать его
    полностью, а не только для UI. Настройки и даже некоторую базовую информацию (данные о текущем
    пользователе, токен авторизации и т.д.) принято хранить в SharedPreferences. Физически это
    xml-файл в папке приложения в разделе data, к которому у вас будет очень простой доступ. БД для
    таких вещей применять несколько избыточно.

5. Именование файлов разметки:
    - activity_color - ок
    - listview_fragment - не ок (fragment_listview - ок)
    Просто когда будет десятка 2 экранов, десяток вьюшек и т.д. удобнее, когда открыв папку все
    отсортировано по типу.

6. В gradle добавлена строчка compile 'com.android.support:recyclerview-v7:23.1.0' , однако сам
    виджет не используется. Вообще, жалательно минимизировать количество сторонних либ в проекте
    (соблюдая баланс с изобретением велосипедов, само собой). Тут сразу 2 момента надо держать в
    памяти - ограничение в 65к методов на проект на версиях Android <5 (обойти можно, но зачем к
    этому в принципе приходить?) и то, что проект тяжелеет с каждой добавленной либой. Поэтому,
    неиспользуемые совсем библиотеки, или очень большие комбайны, используемые ради одной фишки -
    это не очень хорошо.

7. На Activity с настройками нет up навигации.

8. Просмотрите все ворнинги по проекту. Они чаще всего подсказывают, как сделать код лучше.
    Если без них не обойтись (а такое бывает, отпишу ниже), то следует использовать аннотацию
    @SupressWarning("WARNING_NAME") у метода или у класса. Например, с выходом 5.0 Google обновил
    API для работы с камерой, но при этом все версии ОС <5 его не поддерживают. Старое API стало
    deprecated и, соответственно, вылятся ворнинги. В таких случаях есть 2 варианта - делать
    проверку на версию ОС и писать сразу 2 разных кода, либо использовать deprecated API, что в
    большинстве случаев является более рациональным решением.

9. ManageChronometer
    boolean getIsChronometerRunning()
    В JAVA принято именовать методы, возвращающие Boolean или boolean без префикса "get". В данном
    случае - isChronometerRunning().

10. Есть баг: запускаем приложение, запускаем таймер. Закрываем приложение кнопкой "Back"
    устройства. Таймер в нотификация в шторке остановливается. Запускаем приложение, переходим на
    вкладку таймера - он начинает продолжать отсчет времени.

11. Для того, чтобы цвет применился, приходится осуществлять выход из приложения. Чтобы этого
    избежать достаточно в onResume() StopwatchActivity добавить проверку текущего цвета.

12. Баг: секундомер запоминает время:
    - Запустить секундомер
    - Остановить секундомер
    - Выйти из приложения
    - Зайти в приложение кнопкой "Back"
    - Нажать на старт - время начнет отсчет не с нуля, а с момента, когда мы его становили

13. Баг: кнопка остановить/запустить таймера не меняет свое состояние
    - Запустить таймер, кнопка в ActionBar изменила название на "остановить"
    - Дождаться окончания работы таймера, кнопка в ActionBar так и осталась "остановить"

14. Небольшое замечанию по UX. Уведомление должно быть неубиваемым тогда, когда это действительно
    требуется. В момент работы таймера/секундомера - все ок. Но когда таймер закончил работу,
    уведомление "Done" должна быть возможность удалить свайпом.